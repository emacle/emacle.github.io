<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>token on ~振鹭于飞~</title>
    <link>/tags/token/</link>
    <description>Recent content in token on ~振鹭于飞~</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 17 Jan 2020 10:39:00 +0800</lastBuildDate>
    
	<atom:link href="/tags/token/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>vue token过期无缝刷新</title>
      <link>/posts/vue-token-guo-qi-wu-feng-shua-xin/</link>
      <pubDate>Fri, 17 Jan 2020 10:39:00 +0800</pubDate>
      
      <guid>/posts/vue-token-guo-qi-wu-feng-shua-xin/</guid>
      <description>思路:
  登录时, 后端生成 access_token, refresh_token 返回前端, 前端保存两个token在 cookie或localstorge中
  当前端发送正常请求时,请求头字段携带 access_token , 后端提取该 access_token
 判断是否过期, 不过期则返回 HTTP 200 OK 过期返回 HTTP_UNAUTHORIZED 401, 并且加上自定义响应数据 code = 50014 表示access_token 过期    VUE前端使用 响应拦截器 , 对收到的 HTTP 401 进行拦截, 如果 http 401 且 code =50014 则先以 refresh_token 去获取新 access_token
 如果正常获得 access_token, 则再次以新 access_token 发送原请求, 即可实现无缝刷新 如果 refresh_token 也过期, 则服务器也返回 401, 但是加上了自定义响应数据 code= 50015, 前端的响应拦截器 再次捕获到 error , 校验code =50015后, 则强制退出需要重新登录  // response interceptorservice.</description>
    </item>
    
  </channel>
</rss>