<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vue on ~振鹭于飞~</title>
    <link>/tags/vue/</link>
    <description>Recent content in vue on ~振鹭于飞~</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 06 Mar 2020 11:42:00 +0800</lastBuildDate>
    
	<atom:link href="/tags/vue/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vue Element-ui Github oAuth 三方登录</title>
      <link>/posts/vue-element-ui-github-oauth-san-fang-deng-lu/</link>
      <pubDate>Fri, 06 Mar 2020 11:42:00 +0800</pubDate>
      
      <guid>/posts/vue-element-ui-github-oauth-san-fang-deng-lu/</guid>
      <description>Github 网站创建 OAuth Apps 记录 Client ID / Client Secret / Authorization Callback URL 3个参数 此处 Authorization Callback URL 为默认回调网址，程序代码里没有明确指定的话，以此为默认值 
  socialsignin.vue 三方登录模块里，构造弹出窗口 github 认证 url
githubHandleClick(thirdpart) {// 1. 指定授权 client_id 及 redirect_uri 的 URL// 如果不指定 redirect_uri, 则默认使用 gihtub =&amp;gt; Settings =&amp;gt; Developer settings =&amp;gt; OAuth Apps 里 Authorization callback URL 配置的地址// 为了无歧义尽量指定redirect_uriconst url = &amp;#39;https://github.com/login/oauth/authorize?client_id=94aae05609c96ffb7d3b&amp;amp;redirect_uri=http://localhost:9527/auth-redirect&amp;#39;// 2. 弹出子窗口进行授权, 子窗口完成授权后, 子窗口地址栏URL 会是 redirect_uri 并带上 ?</description>
    </item>
    
    <item>
      <title>vue token过期无缝刷新</title>
      <link>/posts/vue-token-guo-qi-wu-feng-shua-xin/</link>
      <pubDate>Fri, 17 Jan 2020 10:39:00 +0800</pubDate>
      
      <guid>/posts/vue-token-guo-qi-wu-feng-shua-xin/</guid>
      <description>过期刷新流程图: 
思路:
  登录时, 后端生成 access_token, refresh_token 返回前端, 前端保存两个token在 cookie或localstorge中
  当前端发送正常请求时,请求头字段携带 access_token , 后端提取该 access_token
 判断是否过期, 不过期则返回 HTTP 200 OK 过期返回 HTTP_UNAUTHORIZED 401, 并且加上自定义响应数据 code = 50014 表示access_token 过期    VUE前端使用 响应拦截器 , 对收到的 HTTP 401 进行拦截, 如果 http 401 且 code =50014 则先以 refresh_token 去获取新 access_token
 如果正常获得 access_token, 则再次以新 access_token 发送原请求, 即可实现无缝刷新 如果 refresh_token 也过期, 则服务器也返回 401, 但是加上了自定义响应数据 code= 50015, 前端的响应拦截器 再次捕获到 error , 校验code =50015后, 则强制退出需要重新登录  // response interceptorservice.</description>
    </item>
    
  </channel>
</rss>